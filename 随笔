说说JSON和JSONP，也许你会豁然开朗
作者: 随它去吧  来源: 博客园  发布时间: 2012-07-16 14:33  阅读: 149581 次  推荐: 397   原文链接   [收藏]  
　　前言
　　由于Sencha Touch 2这种开发模式的特性，基本决定了它原生的数据交互行为几乎只能通过AJAX来实现。
　　当然了，通过调用强大的PhoneGap插件然后打包，你可以实现100%的Socket通讯和本地数据库功能，又或者通过HTML5的WebSocket也可以实现与服务器的通讯和服务端推功能，但这两种方式都有其局限性，前者需要PhoneGap支持，后者要求用户设备必须支持WebSocket，因此都不能算是ST2的原生解决方案，原生的只有AJAX。
　　说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。
　　但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。
　　JSON(JavaScript Object Notation)和JSONP(JSON with Padding)虽然只有一个字母的差别，但其实他们根本不是一回事儿：JSON是一种数据交换格式，而JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。我们拿最近比较火的谍战片来打个比方，JSON是地下党们用来书写和交换情报的“暗号”，而JSONP则是把用暗号书写的情报传递给自己同志时使用的接头方式。看到没？一个是描述信息的格式，一个是信息传递双方约定的方法。
　　既然随便聊聊，那我们就不再采用教条的方式来讲述，而是把关注重心放在帮助开发人员理解是否应当选择使用以及如何使用上。
　　什么是JSON
　　前面简单说了一下，JSON是一种基于文本的数据交换方式，或者叫做数据描述格式，你是否该选用他首先肯定要关注它所拥有的优点。 
　　JSON的优点：
　　1、基于纯文本，跨平台传递极其简单；
　　2、Javascript原生支持，后台语言几乎全部支持；
　　3、轻量级数据格式，占用字符数量极少，特别适合互联网传递；
　　4、可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的；
　　5、容易编写和解析，当然前提是你要知道数据结构；
　　JSON的缺点当然也有，但在作者看来实在是无关紧要的东西，所以不再单独说明。
　　JSON的格式或者叫规则：
　　JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。
　　1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号""是定义符。
　　2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。
　　3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。
　　4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”"，以便于不同语言的解析。
　　5、JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了，只是建议如果客户端没有按日期排序功能需求的话，那么把日期时间直接作为字符串传递就好，可以省去很多麻烦。
　　JSON实例：
// 描述一个人 
var person = {
    "Name": "Bob",
    "Age": 32,
    "Company": "IBM",
    "Engineer": true
}
 
// 获取这个人的信息 
var personAge = person.Age;
 
// 描述几个人 
var members = [
    {
        "Name": "Bob",
        "Age": 32,
        "Company": "IBM",
        "Engineer": true
    },
    {
        "Name": "John",
        "Age": 20,
        "Company": "Oracle",
        "Engineer": false
    },
    {
        "Name": "Henry",
        "Age": 45,
        "Company": "Microsoft",
        "Engineer": false
    }
]
 
// 读取其中John的公司名称 
var johnsCompany = members[1].Company;
 
// 描述一次会议 
var conference = {
    "Conference": "Future Marketing",
    "Date": "2012-6-1",
    "Address": "Beijing",
    "Members":
    [
        {
            "Name": "Bob",
            "Age": 32,
            "Company": "IBM",
            "Engineer": true
        },
        {
            "Name": "John",
            "Age": 20,
            "Company": "Oracle",
            "Engineer": false
        },
        {
            "Name": "Henry",
            "Age": 45,
            "Company": "Microsoft",
            "Engineer": false
        }
    ]
}
 
// 读取参会者Henry是否工程师 
var henryIsAnEngineer = conference.Members[2].Engineer;
　　关于JSON，就说这么多，更多细节请在开发过程中查阅资料深入学习。
　　什么是JSONP
　　先说说JSONP是怎么产生的： 
　　其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。
　　1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；
　　2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<script>、<img>、<iframe>）；
　　3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；
　　4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；
　　5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。
　　6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。
　　7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。
　　如果对于callback参数如何使用还有些模糊的话，我们后面会有具体的实例来讲解。
　　JSONP的客户端具体实现：
　　不管jQuery也好，ExtJs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现：
　　1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。
　　远程服务器remoteserver.com根目录下有个remote.js文件代码如下：
alert('我是远程文件');
　　本地服务器localserver.com下有个jsonp.html页面代码如下：
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
 
</body>
</html>
　　毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。
　　2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。
　　jsonp.html页面代码如下：
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>
 
</body>
</html>
　　remote.js文件代码如下：
localHandler({"result":"我是远程js带来的数据"});
　　运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。
　　3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。
　　看jsonp.html页面的代码：
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script);
    </script>
</head>
<body>
 
</body>
</html>
　　这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。
　　我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。
　　OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：
flightHandler({
    "code": "CA1998",
    "price": 1780,
    "tickets": 5
});
　　我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！
　　4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。
　　什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）：
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 <html xmlns="http://www.w3.org/1999/xhtml" >
 <head>
     <title>Untitled Page</title>
      <script type="text/javascript" src=jquery.min.js"></script>
      <script type="text/javascript">
     jQuery(document).ready(function(){
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
 </html>
　　是不是有点奇怪？为什么我这次没有写flightHandler这个函数呢？而且竟然也运行成功了！哈哈，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用，是不是很爽呀？
　　好啦，写到这里，我已经无力再写下去，又困又累，得赶紧睡觉。朋友们要是看这不错，觉得有启发，给点个“推荐”呗！由于实在比较简单，所以就不再提供demo源码下载了。
　　没想到上了博客园的头条推荐。看到大家对这篇文章的认可和评论，还是很开心的，这里针对ajax与jsonp的异同再做一些补充说明：
　　4月20日下午补充
　　1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；
　　2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。
　　3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。
　　4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。
　　总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！












jQuery Ajax 全解析
本文地址: jQuery Ajax 全解析
本文作者：QLeelulu
转载请标明出处！
jQuery确实是一个挺好的轻量级的JS框架，能帮助我们快速的开发JS应用，并在一定程度上改变了我们写JavaScript代码的习惯。
废话少说，直接进入正题，我们先来看一些简单的方法，这些方法都是对jQuery.ajax()进行封装以方便我们使用的方法，当然，如果要处理复杂的逻辑，还是需要用到jQuery.ajax()的(这个后面会说到).
1. load( url, [data], [callback] ) ：载入远程 HTML 文件代码并插入至 DOM 中。
url (String) : 请求的HTML页的URL地址。
data (Map) : (可选参数) 发送至服务器的 key/value 数据。
callback (Callback) : (可选参数) 请求完成时(不需要是success的)的回调函数。
这个方法默认使用 GET 方式来传递的，如果[data]参数有传递数据进去，就会自动转换为POST方式的。jQuery 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 "url #some > selector"。
这个方法可以很方便的动态加载一些HTML文件，例如表单。
示例代码：
$(".ajax.load").load("http://www.cnblogs.com/QLeelulu/archive/2008/03/30/1130270.html .post",
		function (responseText, textStatus, XMLHttpRequest){
		this;//在这里this指向的是当前的DOM对象，即$(".ajax.load")[0]	
		//alert(responseText);//请求返回的内容
		//alert(textStatus);//请求状态：success，error
		//alert(XMLHttpRequest);//XMLHttpRequest对象
});



2. jQuery.get( url, [data], [callback] )：使用GET方式来进行异步请求
参数：
url (String) :  发送请求的URL地址.
data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示，会做为QueryString附加到请求URL中。
callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。
这是一个简单的 GET 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。示例代码：
		$.get("./Ajax.aspx", {Action:"get",Name:"lulu"}, function (data, textStatus){
				//返回的 data 可以是 xmlDoc, jsonObj, html, text, 等等.
				this; // 在这里this指向的是Ajax请求的选项配置信息，请参考下图
				alert(data);
				//alert(textStatus);//请求状态：success，error等等。
                                  当然这里捕捉不到error，因为error的时候根本不会运行该回调函数
				//alert(this);
		});
点击发送请求：
jQuery.get()回调函数里面的 this ，指向的是Ajax请求的选项配置信息：
 
 
3. jQuery.post( url, [data], [callback], [type] ) ：使用POST方式来进行异步请求
参数：
url (String) : 发送请求的URL地址.
data (Map) : (可选) 要发送给服务器的数据，以 Key/value 的键值对形式表示。
callback (Function) : (可选) 载入成功时回调函数(只有当Response的返回状态是success才是调用该方法)。
type (String) : (可选)官方的说明是：Type of data to be sent。其实应该为客户端请求的类型(JSON,XML,等等)
这是一个简单的 POST 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。示例代码：
Ajax.aspx：
Response.ContentType = "application/json";
Response.Write("{result: '" + Request["Name"] + ",你好！(这消息来自服务器)'}");
jQuery 代码：
$.post("Ajax.aspx", { Action: "post", Name: "lulu" },
		function (data, textStatus){
			// data 可以是 xmlDoc, jsonObj, html, text, 等等.
			//this; // 这个Ajax请求的选项配置信息，请参考jQuery.get()说到的this
			alert(data.result);
		}, "json");
点击提交：
这里设置了请求的格式为"json"：
 
如果你设置了请求的格式为"json"，此时你没有设置Response回来的ContentType 为：Response.ContentType = "application/json"; 那么你将无法捕捉到返回的数据。
注意一下，alert(data.result); 由于设置了Accept报头为“json”，这里返回的data就是一个对象，并不需要用eval()来转换为对象。
 
4. jQuery.getScript( url, [callback] ) : 通过 GET 方式请求载入并执行一个 JavaScript 文件。
参数
url (String) : 待载入 JS 文件地址。
callback (Function) : (可选) 成功载入后回调函数。
jQuery 1.2 版本之前，getScript 只能调用同域 JS 文件。 1.2中，您可以跨域调用 JavaScript 文件。注意：Safari 2 或更早的版本不能在全局作用域中同步执行脚本。如果通过 getScript 加入脚本，请加入延时函数。
这个方法可以用在例如当只有编辑器focus()的时候才去加载编辑器需要的JS文件.下面看一些示例代码：
加载并执行 test.js。
jQuery 代码:
$.getScript("test.js");
________________________________________
加载并执行 AjaxEvent.js ，成功后显示信息。
jQuery 代码:
$.getScript("AjaxEvent.js", function(){
		alert("AjaxEvent.js 加载完成并执行完成.你再点击上面的Get或Post按钮看看有什么不同？");
});



jQuery Ajax 事件
Ajax请求会产生若干不同的事件，我们可以订阅这些事件并在其中处理我们的逻辑。在jQuery这里有两种Ajax事件：局部事件 和 全局事件。
局部事件就是在每次的Ajax请求时在方法内定义的，例如：
 $.ajax({
   beforeSend: function(){
     // Handle the beforeSend event
   },
   complete: function(){
     // Handle the complete event
   }
   // ...
 });
全局事件是每次的Ajax请求都会触发的，它会向DOM中的所有元素广播，在上面 getScript() 示例中加载的脚本就是全局Ajax事件。全局事件可以如下定义：
 $("#loading").bind("ajaxSend", function(){
   $(this).show();
 }).bind("ajaxComplete", function(){
   $(this).hide();
 });
或者：
 $("#loading").ajaxStart(function(){
   $(this).show();
 }); 
我们可以在特定的请求将全局事件禁用，只要设置下 global 选项就可以了：
 $.ajax({
   url: "test.html",
   global: false,// 禁用全局Ajax事件.
   // ...
 });
下面是jQuery官方给出的完整的Ajax事件列表：
•  ajaxStart (Global Event)
This event is broadcast if an Ajax request is started and no other Ajax requests are currently running.
•	beforeSend (Local Event)
This event, which is triggered before an Ajax request is started, allows you to modify the XMLHttpRequest object (setting additional headers, if need be.)
•	ajaxSend (Global Event)
This global event is also triggered before the request is run.
•	success (Local Event)
This event is only called if the request was successful (no errors from the server, no errors with the data).
•	ajaxSuccess (Global Event)
This event is also only called if the request was successful.
•	error (Local Event)
This event is only called if an error occurred with the request (you can never have both an error and a success callback with a request).
•	ajaxError (Global Event)
This global event behaves the same as the local error event.
•	complete (Local Event)
This event is called regardless of if the request was successful, or not. You will always receive a complete callback, even for synchronous requests.
•	ajaxComplete (Global Event)
This event behaves the same as the complete event and will be triggered every time an Ajax request finishes.
•  ajaxStop (Global Event)
This global event is triggered if there are no more Ajax requests being processed.
具体的全局事件请参考API文档。
好了，下面开始说jQuery里面功能最强的Ajax请求方法 $.ajax();  
 
jQuery.ajax( options ) : 通过 HTTP 请求加载远程数据
这个是jQuery 的底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。
$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该对象，但特殊情况下可用于手动终止请求。
注意： 如果你指定了 dataType 选项，请确保服务器返回正确的 MIME 信息，(如 xml 返回 "text/xml")。错误的 MIME 类型可能导致不可预知的错误。见 Specifying the Data Type for AJAX Requests 。
当设置 datatype 类型为 'script' 的时候，所有的远程(不在同一个域中)POST请求都回转换为GET方式。
$.ajax() 只有一个参数：参数 key/value 对象，包含各配置及回调函数信息。详细参数选项见下。
jQuery 1.2 中，您可以跨域加载 JSON 数据，使用时需将数据类型设置为 JSONP。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。数据类型设置为 "jsonp" 时，jQuery 将自动调用回调函数。(这个我不是很懂)
参数列表：
参数名	类型	描述
url	String	(默认: 当前页地址) 发送请求的地址。
type	String	(默认: "GET") 请求方式 ("POST" 或 "GET")， 默认为 "GET"。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。
timeout	Number	设置请求超时时间（毫秒）。此设置将覆盖全局设置。
async	Boolean	(默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
beforeSend	Function	发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。

function (XMLHttpRequest) {
  this; // the options for this ajax request
}
cache	Boolean	(默认: true) jQuery 1.2 新功能，设置为 false 将不会从浏览器缓存中加载请求信息。
complete	Function	请求完成后回调函数 (请求成功或失败时均调用)。参数： XMLHttpRequest 对象，成功信息字符串。

function (XMLHttpRequest, textStatus) {
  this; // the options for this ajax request
}
contentType	String	(默认: "application/x-www-form-urlencoded") 发送信息至服务器时内容编码类型。默认值适合大多数应用场合。
data	Object,
String	发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:["bar1", "bar2"]} 转换为 '&foo=bar1&foo=bar2'。
dataType	String	预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回 responseXML 或 responseText，并作为回调函数参数传递，可用值:
"xml": 返回 XML 文档，可用 jQuery 处理。
"html": 返回纯文本 HTML 信息；包含 script 元素。
"script": 返回纯文本 JavaScript 代码。不会自动缓存结果。
"json": 返回 JSON 数据 。
"jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。
error	Function	(默认: 自动判断 (xml 或 html)) 请求失败时将调用此方法。这个方法有三个参数：XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象。

function (XMLHttpRequest, textStatus, errorThrown) {
  // 通常情况下textStatus和errorThown只有其中一个有值 
  this; // the options for this ajax request
}
global	Boolean	(默认: true) 是否触发全局 AJAX 事件。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 。可用于控制不同的Ajax事件
ifModified	Boolean	(默认: false) 仅在服务器数据改变时获取新数据。使用 HTTP 包 Last-Modified 头信息判断。
processData	Boolean	(默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 "application/x-www-form-urlencoded"。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。
success	Function	请求成功后回调函数。这个方法有两个参数：服务器返回数据，返回状态

function (data, textStatus) {
  // data could be xmlDoc, jsonObj, html, text, etc...
  this; // the options for this ajax request
}
这里有几个Ajax事件参数：beforeSend ，success ，complete ，error 。我们可以定义这些事件来很好的处理我们的每一次的Ajax请求。注意一下，这些Ajax事件里面的this 都是指向Ajax请求的选项信息的(请参考说 get() 方法时的this的图片)。
请认真阅读上面的参数列表，如果你要用jQuery来进行Ajax开发，那么这些参数你都必需熟知的。
示例代码，获取博客园首页的文章题目：
$.ajax({
		type: "get",
		url: "http://www.cnblogs.com/rss",
		beforeSend: function(XMLHttpRequest){
			//ShowLoading();
		},
		success: function(data, textStatus){
			$(".ajax.ajaxResult").html("");
			$("item",data).each(function(i, domEle){
				$(".ajax.ajaxResult").append("<li>"+$(domEle).children("title").text()+"</li>");
			});
		},
		complete: function(XMLHttpRequest, textStatus){
			//HideLoading();
		},
		error: function(){
			//请求出错处理
		}
});



其他
jQuery.ajaxSetup( options ) : 设置全局 AJAX 默认选项。
设置 AJAX 请求默认地址为 "/xmlhttp/"，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。
jQuery 代码:
$.ajaxSetup({
  url: "/xmlhttp/",
  global: false,
  type: "POST"
});
$.ajax({ data: myData });
 
serialize() 与 serializeArray()
serialize() : 序列表表格内容为字符串。
serializeArray() : 序列化表格元素 (类似 '.serialize()' 方法) 返回 JSON 数据结构数据。
示例：
HTML代码：
<p id="results"><b>Results: </b> </p>
<form>
  <select name="single">
    <option>Single</option>
    <option>Single2</option>
  </select>
  <select name="multiple" multiple="multiple">
    <option selected="selected">Multiple</option>
    <option>Multiple2</option>
    <option selected="selected">Multiple3</option>
  </select><br/>
  <input type="checkbox" name="check" value="check1"/> check1
  <input type="checkbox" name="check" value="check2" 
checked="checked"/> check2
  <input type="radio" name="radio" value="radio1" 
checked="checked"/> radio1
  <input type="radio" name="radio" value="radio2"/> radio2
</form> 
 
serializeArray() 结果为：
 
 




进度条标记
示例:<progress class="processbar" id="processbar" max="100" value="5"></progress><label id="processvalue"></label>
 
属性
max 进度条最大值
value 进度条当前值
position 只读属性,value/max 这个值算出来会有很多小数点,需要取整数
 
样式: 进度条样式,FF EDGE CHROME 都不一样,是个灾难
　　边框 border:{1px solid gold;} // 这个容易理解,和其它元素边框一样
　　背景色:background-color:{white;}// 通用设置
　　　　以下是不同浏览器设定
　　　　color: gold; // 背景色(已经完成的进度) IE的高版本

　　　　progress::-moz-progress-bar { background: gold; }// 背景色(已经完成的进度)  火狐

　　　　progress::-webkit-progress-bar { background: white; }// 背景色(整个进度条的背景) 谷歌 
　　　　progress::-webkit-progress-value  { background: gold; }// 背景色(已经完成的进度) 谷歌
　一个简单的示例
1.样式
.processbar {
　　height: 30px;　　　　　　　  // 进度条高度
　　width: 30%;　　　　　　　　// 进度条宽度
　　border: 4px solid gold;        // 进度条边框
　　background-color: red;　　  // 整个进度条背景色
　　color: black;　　　　　　　　// 已经完成的进度 IE高版本(10,11)
}
progress::-webkit-progress-bar {
　　background-color: red;      // 整个进度条的背景 谷歌
}
progress::-webkit-progress-value {
　　background-color: black;   // 已经完成的进度 谷歌
}
progress::-moz-progress-bar {
　　background-color: black;  //  已经完成的进度 火狐
}
2.标记
// 进度条
<progress class="processbar" id="processbar" max="100" value="5"></progress><label id="processvalue"></label>
// 重置
<input type="button" name="" value="重来一次" onclick="resetprocess();" />
3.脚本
<script>　
stepprocessbar();
// 进度条增长
function stepprocessbar() {
　　var pb = document.getElementById("processbar");
　　pb.value = pb.value + 1;
　　// 进度显示label
　　var processlabel = document.getElementById("processvalue");
　　processlabel.innerText= pb.value + '%';
　　processlabel.textContent = pb.value + '%';;// FF 不支持innerText
　　if (pb.value < 100) {
　　　　setTimeout(function () {
　　　　　　stepprocessbar();
　　　　}, 50)
　　}
}
// 重置进度条
function resetprocess() {
　　var pb = document.getElementById("processbar");
　　if (pb.value != 100) return;
　　document.getElementById("processbar").value = 0;
　　stepprocessbar();
}
</script>



关于jquery中on绑定click事件在苹果手机失效的问题


用一个div当做了一个按钮来使用。
<div class="button">
    <div class=" next_button button_left btn_red" style="width: 345px;">
    下一步
    </div>
</div>
因为是动态添加的内容，所以想要使用click事件，需要给他用on绑定一下：
$(document).on("click",".next_button",function(){
    alert();
});
这个时候，使用苹果手机访问的时候，发现了一个坑爹的问题，如论如何点击“下一步”，都没有任何反应，可是在安卓和各种模拟器中一切正常。后来经过查找资料才知道，苹果有这么个设置： 
对于点击的对象，拥有cursor:pointer这个样式的设置，也就是说，鼠标放上去，能够出现“手”型的图标才被认作可以使用点击事件，于是果断增加了样式

<style> .next_button{ cursor:pointer } </style>




我尝试用jQuery控制HTML5视频，两个视频分别在两个tab中，我希望点中tab后，该tab里的视频可以立即播放，而另外tab里的视频能够停止。
我的代码是这样的：
1
2
3	$('#playMovie1').click(function(){
$('#movie1').play();
});
但发现这样不行，而用以下的js是可以的：
1	document.getElementById('movie1').play();
解决方法：
play并不是jQuery的函数，而是DOM元素的函数，所以我们需要通过DOM来调用play，代码如下：
1	$('#videoId').get(0).play();
最简单的方法实现Play和Pause:
1
2	$('video').trigger('play');
$('video').trigger('pause');

点击视频就能播放和暂停
1
2
3
4
5
6
7
8
9
10
11
12
13	$("video").trigger("play");//for auto play
$("video").addClass('pause');//for check pause or play add a class
$('video').click(function() {
if ($(this).hasClass('pause')) {
$("video").trigger("play");
$(this).removeClass('pause');
$(this).addClass('play');
} else {
$("video").trigger("pause");
$(this).removeClass('play');
$(this).addClass('pause');
}
})
静音和取消静音
1
2
3
4
5
6
7
8
9
10
11	$('body').find("video").attr('id', 'video')
var myVid = document.getElementById("video");
$('.sound-icon').click(function() {
//here "sound-icon" is a anchor class. 
var sta = myVid.muted;
if (sta == true) {
myVid.muted = false;
} else {
myVid.muted = true;
}
})
HTML 5中播放视频的方法：
1
2
3
4	<video width="640" height="360" src="http://www.youtube.com/demo/google_main.mp4" controls autobuffer>
<p> Try this page in Safari 4! Or you can 
<a href="http://www.youtube.com/demo/google_main.mp4">download the video</a> instead.</p>
</video>
自动播放：
1
2	<video src="abc.mov" autoplay>
</video>
使用poster在视频无法加载时显示图片：
1
2
3	<video width="640" height="360" src="http://www.youtube.com/demo/google_main.mp" autobuffer controls poster="whale.png">
<p>Try this page in Safari 4! Or you can <a href="http://www.youtube.com/demo/google_main.mp4">download the video</a> instead.</p>
</video>
一个比较简洁的例子：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36	<script type="text/javascript">
function vidplay() {
var video = document.getElementById("Video1");
var button = document.getElementById("play");
if (video.paused) {
video.play();
button.textContent = "||";
} else {
video.pause();
button.textContent = ">";
}
}
function restart() {
var video = document.getElementById("Video1");
video.currentTime = 0;
}
function skip(value) {
var video = document.getElementById("Video1");
video.currentTime += value;
} 
</script>
</head>
<body>
<video id="Video1" >
// Replace these with your own video files. 
<source src="demo.mp4" type="video/mp4" />
<source src="demo.ogv" type="video/ogg" />
HTML5 Video is required for this example. 
<a href="demo.mp4">Download the video</a> file. 
</video>
<div id="buttonbar">
<button id="restart" onclick="restart();">[]</button> 
<button id="rew" onclick="skip(-10)">&lt;&lt;</button>
<button id="play" onclick="vidplay()">&gt;</button>
<button id="fastFwd" onclick="skip(10)">&gt;&gt;</button>
</div>

下面是一个比较完整的例子：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160	<html >
<head>
<title>Full player example</title>
<!-- Uncomment the following meta tag if you have issues rendering this page on an intranet or local site. --> 
<!-- <meta http-equiv="X-UA-Compatible" content="IE=edge"/> -->
<script type="text/javascript">
function init() { // Master function, encapsulates all functions
var video = document.getElementById("Video1"); 
if (video.canPlayType) { // tests that we have HTML5 video support
// if successful, display buttons and set up events
document.getElementById("buttonbar").style.display = "block"; 
document.getElementById("inputField").style.display = "block";
// helper functions
// play video
function vidplay(evt) {
if (video.src == "") { // inital source load
getVideo();
}
button = evt.target; // get the button id to swap the text based on the state 
if (video.paused) { // play the file, and display pause symbol
video.play();
button.textContent = "||";
} else { // pause the file, and display play symbol 
video.pause();
button.textContent = ">";
}
}
// load video file from input field
function getVideo() {
var fileURL = document.getElementById("videoFile").value; // get input field 
if (fileURL != "") {
video.src = fileURL;
video.load(); // if HTML source element is used
document.getElementById("play").click(); // start play
} else {
errMessage("Enter a valid video URL"); // fail silently
}
}
  
// button helper functions 
// skip forward, backward, or restart
function setTime(tValue) {
// if no video is loaded, this throws an exception 
try {
if (tValue == 0) {
video.currentTime = tValue;
}
else {
video.currentTime += tValue;
}
 
} catch (err) {
// errMessage(err) // show exception
errMessage("Video content might not be loaded");
}
}
// display an error message 
function errMessage(msg) {
// displays an error message for 5 seconds then clears it
document.getElementById("errorMsg").textContent = msg;
setTimeout("document.getElementById('errorMsg').textContent=''", 5000);
}
// change volume based on incoming value 
function setVol(value) {
var vol = video.volume;
vol += value;
// test for range 0 - 1 to avoid exceptions
if (vol >= 0 && vol <= 1) {
// if valid value, use it
video.volume = vol;
} else {
// otherwise substitute a 0 or 1
video.volume = (vol < 0) ? 0 : 1; 
}
}
// button events 
// Play
document.getElementById("play").addEventListener("click", vidplay, false);
// Restart
document.getElementById("restart").addEventListener("click", function () {
setTime(0);
}, false);
// Skip backward 10 seconds
document.getElementById("rew").addEventListener("click", function () {
setTime(-10);
}, false);
// Skip forward 10 seconds
document.getElementById("fwd").addEventListener("click", function () {
setTime(10);
}, false);
// set src == latest video file URL
document.getElementById("loadVideo").addEventListener("click", getVideo, false);
// fail with message 
video.addEventListener("error", function (err) {
errMessage(err);
}, true);
// volume buttons
document.getElementById("volDn").addEventListener("click", function () {
setVol(-.1); // down by 10%
}, false);
document.getElementById("volUp").addEventListener("click", function () {
setVol(.1); // up by 10%
}, false);
// playback speed buttons
document.getElementById("slower").addEventListener("click", function () {
video.playbackRate -= .25;
}, false);
document.getElementById("faster").addEventListener("click", function () {
video.playbackRate += .25;
}, false);
document.getElementById("normal").addEventListener("click", function () {
video.playbackRate = 1;
}, false);
document.getElementById("mute").addEventListener("click", function (evt) {
if (video.muted) {
video.muted = false;
evt.target.innerHTML = "<img alt='volume on button' src='vol2.png' />"
} else {
video.muted = true;
evt.target.innerHTML = "<img alt='volume off button' src='mute2.png' />"
}
}, false);
} // end of runtime
}// end of master 
</script>
 
</head>
<body onload="init();" > 
 
<video id="Video1" controls style="border: 1px solid blue;" height="240" width="320" title="video element"> 
HTML5 Video is required for this example
</video>
 
<div id="buttonbar" style="display: none;")>
<button id="restart" title="Restart button">[]</button> 
<button id="slower" title="Slower playback button">-</button> 
<button id="rew" title="Rewind button" >&lt;&lt;</button>
<button id="play" title="Play button">&gt;</button>
<button id="fwd" title="Forward button" >&gt;&gt;</button>
<button id="faster" title="Faster playback button">+</button>
<button id="Button2" title="Mute button" ><img alt="Volume on button" src="vol2.png" /></button> 
<br />
<label>Playback </label>
<label>Reset playback rate: </label><button id="normal" title="Reset playback rate button">=</button> 
 
<label> Volume </label>
<button id="volDn" title="Volume down button">-</button>
<button id="volUp" title="Volume up button">+</button>
<button id="mute" title="Mute button" ><img alt="Volume on button" src="vol2.png" /></button> 
</div> 
<br/> 
<div id= "inputField" style="display:none;" >
<label>Type or paste a video URL: <br/>
<input type="text" id="videoFile" style="width: 300px;" title="video file input field" value="http://ie.microsoft.com/testdrive/ieblog/2011/nov/pp4_blog_demo.mp4" /> 
<button id="loadVideo" title="Load video button" >Load</button>
</label>
</div>
<div title="Error message area" id="errorMsg" style="color:Red;"></div> 
</body>
</html>





适用于未创建的元素
$(document).ready(function(){
  $("div").on("click","p",function(){
    $(this).slideToggle();
  });
  $("button").click(function(){
    $("<p>This is a new paragraph.</p>").insertAfter("button");
  });
});




2016-11-15
//1、获取和设置样式
$("#tow").attr("class")获取ID为tow的class属性
$("#two").attr("class","divClass")设置Id为two的class属性。
//2、追加样式
$("#two").addClass("divClass2")为ID为two的对象追加样式divClass2
//3、移除样式
$("#two").removeClass("divClass")移除 ID为two的对象的class名为divClass的样式。
$(#two).removeClass("divClass divClass2")移除多个样式。
//4、切换类名
$("#two").toggleClass("anotherClass") //重复切换anotherClass样式
//5、判断是否含有某项样式
$("#two").hasClass("another")==$("#two").is(".another");
//6、获取css样式中的样式
$("div").css("color") 设置color属性值. $(element).css(style)
//设置单个样式
$("div").css("color","red")
//设置多个样式
$("div").css({fontSize:"30px",color:"red"})
$("div").css("height","30px")==$("div").height("30px")
$("div").css("width","30px")==$("div").height("30px")
//7.offset()方法
//它的作用是获取元素在当前视窗的相对偏移，其中返回对象包含两个属性,即top和left 。
//注意：只对可见元素有效。
var offset=$("div").offset();
var left=offset.left;         //获取左偏移
var top=offset.top;        //获取右偏移
//8、position()方法
//它的作用是获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，与offset()一样，它返回的对象也包括两个属性即top和left。
//9、scrollTop()方法和scrollLeft()方法
$("div").scrollTop();        //获取元素的滚动条距顶端的距离。
$("div").scrollLeft();         //获取元素的滚动条距左侧的距离。
//10、jQuery中的 toggle和slideToggle 方法，都可以实现对一个元素的显示和隐藏。区别是：
//toggle：动态效果为从右至左。横向动作。
//slideToggle：动态效果从下至上。竖向动作。
//比如想实现一个树由下至上收缩的动态效果，就使用slideToggle就ok了。
$('input').attr("readonly",true)//将input元素设置为readonly
$('input').attr("readonly",false)//去除input元素的readonly属性
$('input').attr("disabled",true)//将input元素设置为disabled
$('input').attr("disabled",false)//去除input元素的disabled属性






2016-12-01
-webkit-animation:仍旧是一个复合属性，
-webkit-animation: name duration timing-function delay iteration_count direction;
包括以下几个属性
（1）  -webkit-animation-name    这个属性的使用必须结合@-webkit-keyframes一起使用
eg:  @-webkit-keyframes fontchange{
0%{font-size:10px;}
30%{font-size:15px;}
100%{font-siez:12px;}
}
百分比的意思就是duration的百分比，如果没有设置duration的话，则表示为无穷大
div{ -webkit-animation-name:fontchange;}
（2）-webkit-animation-duration   表示动画持续的时间
（3）-webkit-animation-timing-function  表示动画使用的时间曲线
【语法】： -webkit-animation-timing-function: ease | linear | ease-in | ease-out | ease-in-out
（4）-webkit-animation-delay    表示开始动画之前的延时
【语法】 -webkit-animation-delay: delay_time;
（5）-webkit-animation-iteration-count  表示动画要重复几次
【语法】-webkit-animation-iteration-count: times_number;
（6） -webkit-animation-direction   表示动画的方向
【语法】-webkit-animation-direction: normal(默认)  | alternate
normal  方向始终向前
alternate 当重复次数为偶数时方向向前，奇数时方向相反
【另外】跟animation有关的其他属性
（1）-webkit-animation-fill-mode : none (默认)| backwards | forwards | both  设置动画开始之前和结束之后的行为（测试结
果不是很清晰）
（2）-webkit-animation-play-state: running（默认） | paused  设置动画的运行状态
综合案例：
@-webkit-keyframes fontbulger {
0% {
font-size: 10px;
}
30% {
font-size: 15px;
}
100% {
font-size: 12px;
}
}
#box {
-webkit-animation-name:  fontbulger;
-webkit-animation-duration: 1s;
-webkit-animation-iteration-count:3;
-webkit-animation-direction: alternate;
-webkit-animation-timing-function: ease-out;
-webkit-animation-fill-mode: both;
-webkit-animation-delay: 2s;
}
<div id=”box”>文字变化</div>




2016-12-06
scroll()函数用于为每个匹配元素的scroll事件绑定处理函数。该函数也可用于触发scroll事件。此外，你还可以额外传递给事件处理函数一些数据。
scroll事件会在元素的滚动条位置发生改变时触发。该事件一般仅适用于window对象或其他可滚动元素(一般会出现滚动条)。
此外，你可以为同一元素多次调用该函数，从而绑定多个事件处理函数。触发scroll事件时，jQuery会按照绑定的先后顺序依次执行绑定的事件处理函数。
要删除通过scroll()绑定的事件，请使用unbind()函数。
该函数属于jQuery对象(实例)。
语法
jQueryObject.scroll( [ [ data ,]  handler ] )
如果指定了至少一个参数，则表示绑定scroll事件的处理函数；没有指定任何参数，则表示触发scroll事件。
参数
参数	描述
data	可选/任意类型触发事件时，需要通过event.data传递给事件处理函数的任意数据。

handler	可选/Function类型指定的事件处理函数。
jQuery 1.4.3 新增支持：scroll()支持data参数。
参数handler中的this指向当前DOM元素。scroll()还会为handler传入一个参数：表示当前事件的Event对象。
如果函数handler的返回值为false，则表示阻止元素的默认事件行为，并停止事件在DOM树中冒泡。例如，<a>链接的click事件的处理函数返回false，可以阻止链接的默认URL跳转行为。<form>表单的scroll事件的处理函数返回false，可以阻止表单默认的表单提交行为。
scroll()函数的返回值为jQuery类型，返回当前jQuery对象本身。
示例&说明

请参考以下HTML示例代码：
<div id="msg" style="height: 3000px;" ></div>
现在，我们为window对象的scroll事件绑定处理函数(可以绑定多个，触发时按照绑定顺序依次执行)：
$(window).scroll( function(event){
    $("#msg").append( $(this).scrollTop() + '<br>' );
} );

// 触发window对象的scroll事件
// $(window).scroll( );

我们还可以为事件处理函数传递一些附加的数据。此外，通过jQuery为事件处理函数传入的参数Event对象，我们可以获取当前事件的相关信息(比如事件类型、触发事件的DOM元素、附加数据等)：
var maxScrollTop = 1000;

// 向下滚动到据顶部超过1000px时，回到顶部
$(window).scroll( maxScrollTop, function(event){
    var $me = $(this);
    if( $me.scrollTop() > event.data ){
        $me.scrollTop( 0 );
    }
} );


2016-12-09
JavaScript eval() 函数
JavaScript 全局对象
定义和用法
eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
语法
eval(string)
参数	描述
string	必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。





使用jquery获取url以及使用jquery获取url参数是我们经常要用到的操作，下面通过文字说明加代码分析的形式给大家解析，具体详情请看下文。
1、jquery获取url很简单，代码如下：
复制代码代码如下:

window.location.href;


其实只是用到了javascript的基础的window对象，并没有用jquery的知识。
2、jquery获取url参数比较复杂，要用到正则表达式，所以学好javascript正则式多么重要的事情
首先看看单纯的通过javascript是如何来获取url中的某个参数：
?
1
2
3
4
5
6	//获取url中的参数
function getUrlParam(name) {
 var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); //构造一个含有目标参数的正则表达式对象
 var r = window.location.search.substr(1).match(reg); //匹配目标参数
 if (r != null) return unescape(r[2]); return null; //返回参数值
}

通过这个函数传递url中的参数名就可以获取到参数的值，比如url为
http://localhost:33064/WebForm2.aspx?reurl=WebForm1.aspx
我们要获取reurl的值，可以这样写：
复制代码代码如下:

var xx = getUrlParam('reurl');
明白了javascript获取url参数的方法，我们可以通过这个方法为jquery扩展一个方法来通过jquery获取url参数，下面的代码为jquery扩展了一个getUrlParam()方法
?
1
2
3
4
5
6
7	(function ($) {
  $.getUrlParam = function (name) {
   var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
   var r = window.location.search.substr(1).match(reg);
   if (r != null) return unescape(r[2]); return null;
  }
 })(jQuery);
为jquery扩展了这个方法了之后我们就可以通过如下方法来获取某个参数的值了：
  
复制代码代码如下:

 var xx = $.getUrlParam('reurl');
完整代码：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26	<script src="js/jquery-1.7.2.min.js" type="text/javascript"></script>
<script type="text/javascript">
 $(function () {
  //方法二：
  (function ($) {
   $.getUrlParam = function (name) {
    var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
    var r = window.location.search.substr(1).match(reg);
    if (r != null) return unescape(r[2]); return null;
   }
  })(jQuery);
  //方法二：
  var xx = $.getUrlParam('reurl');
  //方法一：
  // var xx = getUrlParam('reurl');
 
  alert(xx);
 });
 //方法一：
 //获取url中的参数
 function getUrlParam(name) {
  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)"); //构造一个含有目标参数的正则表达式对象
  var r = window.location.search.substr(1).match(reg); //匹配目标参数
  if (r != null) return unescape(r[2]); return null; //返回参数值
 }
</script>
2014-4-23 修改
今天在用上面的方法获取url中的参数时，url中传递的中文参数在解析的时候无论怎么测试，获取的都是乱码。经过一番调试后发现，我再传递参数时，对汉字编码使用的是 encodeURI ，而上面的方法在解析参数编码时使用的是unescape ,修改为 decodeURI 就可以了。
附： W3School中的介绍：
JavaScript unescape() 函数
unescape() 函数可对通过 escape() 编码的字符串进行解码。
参数	描述
string	必需。要解码或反转义的字符串。
说明
该函数的工作原理是这样的：通过找到形式为 %xx 和 %uxxxx 的字符序列（x 表示十六进制的数字），用 Unicode 字符 \u00xx 和 \uxxxx 替换这样的字符序列进行解码。
提示和注释
注释：ECMAScript v3 已从标准中删除了 unescape() 函数，并反对使用它，因此应该用 decodeURI() 和 decodeURIComponent() 取而代之。
综上： javascript对参数编码解码方法要一致：
escape()   unescape()
encodeURI()   decodeURI()
encodeURIComponent()    decodeURIComponent() 
网上找的另一种javascript获取url中参数的方法：
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25	<script language="JavaScript" type="text/javascript"> 
function GetUrlParms() 
{
 var args=new Object(); 
 var query=location.search.substring(1);//获取查询串 
 var pairs=query.split("&");//在逗号处断开 
 for(var i=0;i<pairs.length;i++) 
 { 
  var pos=pairs[i].indexOf('=');//查找name=value 
   if(pos==-1) continue;//如果没有找到就跳过 
   var argname=pairs[i].substring(0,pos);//提取name 
   var value=pairs[i].substring(pos+1);//提取value 
   args[argname]=unescape(value);//存为属性 
 }
 return args;
}
var args = new Object();
args = GetUrlParms();
//如果要查找参数key:
if(args["id"]!=undefined)
{
//如果要查找参数key:
var value1 = args["id"] ;
alert(value1);
}</script>
 jquery 取url参数和在url加参数
?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28	(function ($) {
 $.extend({
  Request: function (m) {
   var sValue = location.search.match(new RegExp("[\?\&]" + m + "=([^\&]*)(\&?)", "i"));
   return sValue ? sValue[1] : sValue;
  },
  UrlUpdateParams: function (url, name, value) {
   var r = url;
   if (r != null && r != 'undefined' && r != "") {
    value = encodeURIComponent(value);
    var reg = new RegExp("(^|)" + name + "=([^&]*)(|$)");
    var tmp = name + "=" + value;
    if (url.match(reg) != null) {
     r = url.replace(eval(reg), tmp);
    }
    else {
     if (url.match("[\?]")) {
      r = url + "&" + tmp;
     } else {
      r = url + "?" + tmp;
     }
    }
   }
   return r;
  }
 
 });
})(jQuery);
使用方法
dev.zhang.com/IOF.Signup/index_uscn_chs.html?act=1
1、取值使用
$.Request("act") = 1
2、url加参数
$.UrlUpdateParams(window.location.href, "mid", 11111),
结果window.location.href?mid=11111




jquery 如何处理单击<a> 的时候获取href并且让href增加一个参数？
<div id="header">
<h1 class="logo"> <a href="/ " title="欢迎来到砍价网">砍价网</a></h1>
<div id="city_title"></div>
<div class="city_cont">
<dl id="all_cities">
<dt>A-B-C-D-E</dt> 
<dd>
<a class='cityname' lang="74" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=aomen">澳门<span class="count"></span></a>
<a lang="75" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=anqing">安庆<span class="count"></span></a>
<a lang="197" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=anji">安吉<span class="count"></span></a>
</dd>
<dt>F-G-H-I-J</dt>
<dd>
<a class='cityname' lang="2" onclick="sethref(this)" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=fuzhou">福州<span class="count"></span></a>
<a lang="35" onclick="sethref(this)" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=foshan">佛山<span class="count"></span></a>
<a lang="77" onclick="sethref(this)" href="/manage/admin?uid=lgfz&pw=lgfz&CityName=fuyang">阜阳<span class="count"></span></a>
</dd>
上面是我的网站的代码 还有很多<dd> 我想取得所有这些的<a> 的href 并且增加href的参数 比如href="/manage/admin?uid=lgfz&pw=lgfz&CityName=fuyang" 处理完之后 为href="/manage/admin?uid=lgfz&pw=lgfz&CityName=fuyang&url=sigecity"





Jquery向url增加参数
用jQuery实现

$("a").each(function(){
var link = $(this).attr("href");
link = "http://www.baidu.com?" + link;
$(this).attr("href",link);
});



<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "
 
<html xmlns="
 
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script language="javascript" type="text/javascript" src="./javascript/jquery.min.js"></script>
<title>测试</title>
</head>
 
<body>
<a href="1111111111111111.html">1111111111</a>
<a href="2222222222222222.html">2222222222</a>
<script>
    $(function(){
        $("a").each(function(){
            var link = $(this).attr("href");
            var new_link = "http://www.baidu.com/?" + link;
 
            $(this).attr("href",new_link); 
        });
    });
</script>
</body>
</html>


2016-12-13(夜)
//当button1被点击时，触发uploadify的点击事件，打开文件选择器。
$('#button1').on('click',function(){
     $('#uploadify').click();
});
//当选择好文件之后，触发uploadfiy的change事件，然后触发button2的点击事件
$('#uploadify').on('change',function(){
    $('#buttont2').click();
});



2016-12-15

JSON对象
有时候在做项目的时候时常将这两个概念弄混淆，尤其是在使用springmvc的时候，后台@RequestBody接受的是一个json格式的字符串，一定是一个字符串。 
先介绍一下json对象，首先说到对象的概念，对象的属性是可以用：对象.属性进行调用的。例如：
 var person={"name":"tom","sex":"男","age":"24"}//json对象
 console.log(person.name);//在控制台输出tom
 alert(typeof(person));//object
•	1
•	2
•	3
 
•	1
•	2
•	3
以上就是json对象。是一个用perosn.name这种方式进行属性的调用。第三行代码就是看person的类型，为object类型。
JSON字符串
字符串，我们常说的JavaScript中的字符串是单引号或者双引号引起来的。那么json字符串是什么概念呢？
 var b='{"name":"2323","sex":"afasdf","age":"6262"}';//json字符串
 console.log(b);//{"name":"2323","sex":"afasdf","age":"6262"}
  alert(typeof(b));//string
•	1
•	2
•	3
•	4
•	1
•	2
•	3
•	4
以上就是b就是一个字符串，也是一个json字符串，之所以叫json字符串，因为字符串的格式符合json的格式，所以叫做json字符串，第三行代码也匹配其中的类型为string。
json字符串和json对象的转换
json字符串转json对象,调用parse方法：
var b='{"name":"2323","sex":"afasdf","age":"6262"}'//json字符串
var bToObject=JSON.parse(b);
console.log(bToObject.name);//2323
•	1
•	2
•	3
•	1
•	2
•	3
json对象转为json字符串：
var a={"name":"tom","sex":"男","age":"24"}//json对象
var aToString=JSON.stringify(a);
console.log(aToString);//{"name":"tom","sex":"男","age":"24"}


2016-12-22
CSS实现单行、多行文本溢出显示省略号（…）



如果实现单行文本的溢出显示省略号同学们应该都知道用text-overflow:ellipsis属性来，当然还需要加宽度width属来兼容部分浏览。
实现方法：
overflow: hidden;
text-overflow:ellipsis;
white-space: nowrap;
效果如图：
 
但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。
接下来重点说一说多行文本溢出显示省略号，如下。
实现方法：
display: -webkit-box;
-webkit-box-orient: vertical;
-webkit-line-clamp: 3;
overflow: hidden;
效果如图：
 
适用范围：
因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；
注：
1.	-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：
2.	display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
3.	-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。
实现方法：
p{position: relative; line-height: 20px; max-height: 40px;overflow: hidden;}
p::after{content: "..."; position: absolute; bottom: 0; right: 0; padding-left: 40px;
background: -webkit-linear-gradient(left, transparent, #fff 55%);
background: -o-linear-gradient(right, transparent, #fff 55%);
background: -moz-linear-gradient(right, transparent, #fff 55%);
background: linear-gradient(to right, transparent, #fff 55%);
}
效果如图：
 
适用范围：
该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合js优化该方法。
注：
1.	将height设置为line-height的整数倍，防止超出的文字露出。
2.	给p::after添加渐变背景可避免文字只显示一半。
3.	由于ie6-7不显示content内容，所以要添加标签兼容ie6-7（如：<span>…<span/>）；兼容ie8需要将::after替换成:after。


实现一个三列布局(左右侧固定，中间自适应宽度)
来源：博客园2016-04-15
html代码(第一二种方法):
<div class="left">左侧固定区</div> <div class="right">右侧固定区</div> <div class="mid">中间自适应区</div>
 
css代码：
第一种方法（定位）：
.left { position: absolute; top: 0; left: 0; width: 100px; height: 200px; background-color: red; } .mid { margin-left: 100px; margin-right: 200px; height: 200px; background-color: blue; } .right { position: absolute; top: 0; right: 0; width: 200px; height: 200px; background-color: yellow; }
 
第二种方法（浮动）：
.left { float: left; width: 100px; height: 200px; background-color: red; } .mid { height: 200px; background-color: blue; } .right { float: right; width: 200px; height: 200px; background-color: yellow; }
 
第三种方法（负边距）：
html代码：
<div class="center fl">  <div class="mid"> 中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区中间自适应区  </div> </div> <div class="left fl">左边固定区</div> <div class="right fl">右边固定区</div>
 
css代码：
.fl { float: left; } .center { width: 100%; height: 200px; background: yellow; } .center .mid{ margin-right: 100px; padding: 0 110px; } .left{ margin-left: -100%; width: 100px; height: 200px; background: green; } .right{ margin-left: -200px; width: 200px; height: 200px; background: blue; }
 

//判断手机终端
//判断是否是移动设备
function isMobile() {
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
return true;
} else {
return false;
}
}



//判断路径是不是微信下载地址
function is_weixin() {
var ua = navigator.userAgent.toLowerCase();
if (ua.match(/MicroMessenger/i) == "micromessenger") {
return true;
} else {
return false;
}
}
// 获取终端的相关信息
var Terminal = {
// 辨别移动终端类型
platform : function() {
var u = navigator.userAgent, app = navigator.appVersion;
return {
// android终端或者uc浏览器
android : u.indexOf('Android') > -1
|| u.indexOf('Linux') > -1,
// 是否为iPhone或者QQHD浏览器
iPhone : u.indexOf('iPhone') > -1,
// 是否iPad
iPad : u.indexOf('iPad') > -1
};
}(),
// 辨别移动终端的语言：zh-cn、en-us、ko-kr、ja-jp...
language : (navigator.browserLanguage || navigator.language)
.toLowerCase()
}



写一个function，清除字符串前后的空格。（兼容所有浏览器）
function trim(str) {
    if (str && typeof str === "string") {
        return str.replace(/(^\s*)|(\s*)$/g,""); //去除前后空白符
    }
}

